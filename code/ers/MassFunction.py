import itertools
import numpy as np

class MassFunction(dict):
	"""
	A Dempster-Shafer mass function (basic probability assignment) based on a dictionary.
	Hypotheses and their associated mass values can be added/changed/removed using the standard dictionary methods.
	Each hypothesis can be an arbitrary sequence which is automatically converted to a 'frozenset', meaning its elements must be hashable.
	"""
	
	def __init__(self, source=None, coreset=None, cold_start="unknow", r=40):
		"""
		Creates a new mass function.
		
		It be a dictionary mapping hypotheses to non-negative mass values
		If 'source' is not None, it is used to initialize the mass function depend on the option of cold start.
		If choosing 'unknow', the remain of mass value be assigned for the core set. 
		Otherwise, the mass values of non-focal set were assigned the mean of the remaining of mass value.
		"""
		total_mass = 0
		self.coreset = coreset
		self.r = r
		if source != None:
			for (h, v) in source:
				self[frozenset(h)] = np.float128(v)
				total_mass += np.float128(v)
		
			if self.coreset == None:
				self.coreset = self.core()
		
		if self.coreset != None:
			if cold_start == "equal":
				initial_mass_value = np.float128((1.0 - total_mass) / (np.power(2, len(self.coreset)) - 1 - len(self)))
				for i in range(len(self.coreset)):
					for hypothesis_set in itertools.combinations(self.coreset,i+1):
						if frozenset(hypothesis_set) not in self:
							self[frozenset(hypothesis_set)] = initial_mass_value
			elif cold_start == "unknow":
				for i in range(len(self.coreset)):
					for hypothesis_set in itertools.combinations(self.coreset,i+1):
						if frozenset(hypothesis_set) not in self:
							self[frozenset(hypothesis_set)] = np.float128(0)
				self[frozenset(self.coreset)] = np.float128(1.0 - total_mass + self[frozenset(self.coreset)])
		# self.__round__()

	def focal(self): 
		"""
		Returns the set of all focal hypotheses.
		
		A focal hypothesis has a mass value greater than 0.
		"""
		return {h for (h, v) in self.items() if v > 0}
	
	def core(self):
		"""
		Returns the core of a mass functions as a 'frozenset'.
		
		The core of a mass function is the union of all its focal hypotheses.
		In case a mass function does not contain any focal hypotheses, its core is an empty set.
		"""
		focal = self.focal()
		if not focal:
			return frozenset()
		else:
			return frozenset.union(*focal)
		
	def combine(self, mass_function):
		"""
		Returns a mass function was generated by combining these two mass funciton (self and mass function)
		
		The function use combination rules in theory of evidence for itegrating evidence.
		"""
		if self.coreset != mass_function.coreset:
			raise TypeError("expected core set of the MassFunctions are the same but got two difference core set: {} and {}".format(self.coreset, mass_function.coreset))
		combined = self
		if isinstance(mass_function, MassFunction):
			mass_function = [mass_function] # wrap single mass function
		for m in mass_function:
			if not isinstance(m, MassFunction):
				raise TypeError("expected type MassFunction but got %s; make sure to use keyword arguments for anything other than mass functions" % type(m))
			combined = combined.__combine_dempster_rule__(m)
		# combined.__round__()
		return combined

	def __combine_dempster_rule__(self, mass_function):
		"""
		Returns a mass function was combined using Dempster's Rule
		
		The function use Dempster's Rule  for combining evidence.
		"""
		# print("Test")
		combined = MassFunction(coreset=self.coreset)
		# print(combined)
		for (h, v) in self.items():
			combined[h] = 0
		total_mass = 0.0
		for (h1, v1) in self.items():
			for (h2, v2) in mass_function.items():
				if len(frozenset.intersection(h1, h2)) != 0:
					combined[frozenset.intersection(h1, h2)] += (v1 * v2)
					total_mass += (v1 * v2)

		# print(combined, total_mass)
		for (h, v) in combined.items():
			combined[h] = combined[h] / total_mass
		return combined
	
	def __solve_totally_conflict__(self):
		"""
		Solving the total conflict between mass functions by adding an epsilon to the Omega set.
		"""
		if self[frozenset(self.coreset)] == 0.0:
			max_hypothesis = None
			max_value = 0.0
			for (h, v) in self.items():
				if v > max_value:
					max_value = v
					max_hypothesis = h
			
			self[frozenset(self.coreset)] = 1e-40
			self[max_hypothesis] = self[max_hypothesis] - 1e-40

	def __round__(self):
		"""
		Returns a rouned mass function
		
		The function use round function for aproximating the mass values in the mass function.
		The parameter 'r' defined the number of decimal for rounding the final mass function.
		"""
		
		total_mass = 0
		# print("----------Round-----------")
		# print(self)
		for i in range(len(self.coreset) - 1):
			for hypothesis_set in itertools.combinations(self.coreset,i + 1):
				self[frozenset(hypothesis_set)] = round(self[frozenset(hypothesis_set)], self.r)
				total_mass = total_mass + self[frozenset(hypothesis_set)]
		# print(total_mass)
		self[frozenset(self.coreset)] = 1.0 - total_mass
		self.__solve_totally_conflict__()
		# print(self)
		# print("---------------------")